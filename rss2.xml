<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rimiiii&#39;s Blog</title>
    <link>https://rimiiii.github.io/</link>
    
    <atom:link href="https://rimiiii.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>이것저것 끄적이는 블로그</description>
    <pubDate>Tue, 15 Jun 2021 14:12:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[논문 리뷰] Benchmarking deep learning models on large healthcare datasets</title>
      <link>https://rimiiii.github.io/2021/06/15/benchmarking-deep-learning-on-healthcare-datasets/</link>
      <guid>https://rimiiii.github.io/2021/06/15/benchmarking-deep-learning-on-healthcare-datasets/</guid>
      <pubDate>Tue, 15 Jun 2021 13:38:50 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;code&gt;MIMIC3&lt;/code&gt;를 이용한 딥러닝 모델들의 벤치마킹 연구 논문을 리뷰하려 한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><code>MIMIC3</code>를 이용한 딥러닝 모델들의 벤치마킹 연구 논문을 리뷰하려 한다.</p><span id="more"></span><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>딥러닝 모델은 다양한 분야에서 많이 사용되고 있다. 그러나 오픈소스 의료데이터를 이용한 머신러닝과 예후 scoring system SOTA 수준의 딥러닝 모델은 거의 없다. 본 논문에서는 딥러닝 모델 또는 머신러닝 모델의 앙상블, SAPS II와 SOFA 점수를 이용한 몇개의 의료 분야에서의 예측(사망, 입원기간, ICD-9 code 그룹) 벤치마킹 결과를 제시하려한다. 해당 연구에서는 ICU 데이터셋인 MIMIC III를 사용하였다. 본 논문의 결과는 딥러닝 모델은 raw clinical time series data를 input feature로 사용하는 모델들에게 지속적인 성능이 나온다는 결과를 보여준다.</p><hr><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>환자의 사망과 입원기간은 ICU 입원에서 가장 중요한 임상 결과이다. 그리고 질병의 중증 측면에서 도움을 줄 수 있고 새로운 치료, 중재 및 건강 관리 정책의 가치를 결정할 수 있다. SAPS-II, SOFA, APACHE와 같은 중증도 점수는 ICU에 들어온 뒤 24시간 내에 얻은 측정값으로 정의되었으며 사망률을 예측하기 위한 목적으로 개발되었다.<br>최근 머신러닝과 딥러닝의 발전과 성공으로 많은 연구자들이 ICU 입원의 임상 예측 작업에 머신러닝과 딥러닝 모델을 체택하였다. 본 논문에서 소개하는 연구들은 다음과 같다.</p><ul><li>머신러닝 앙상블 모델을 이용한 사망률 예측</li><li>gradient boosting과 logistic regression 모델을 이용한 사망률 예측</li><li>딥러닝 모델을 이용한 4개의 임상 예측</li></ul><p>본 연구의 주 기여점은 다음과 같다.</p><ul><li>딥러닝 모델을 이용한 사망률 예측, 입원기간 예측, ICD-9 code 그룹 예측(이 실험들은 머신러닝 모델과 severity scoring system들보다 더 좋은 성능을 나타냈다.</li><li>딥러닝 모델이 clinical feature들의 룰 기반 전처리가 딥러닝 모델에 필요하지 않다는 것을 가르키는 raw feature들의 더 나은 결과를 얻는다는 것을 보여준다.</li></ul><hr><h1 id="MIMIC-III-dataset-preprocessing"><a href="#MIMIC-III-dataset-preprocessing" class="headerlink" title="MIMIC-III dataset preprocessing"></a>MIMIC-III dataset preprocessing</h1><h2 id="Cohort-selection"><a href="#Cohort-selection" class="headerlink" title="Cohort selection"></a>Cohort selection</h2><p>15세보다 많은 나이의 환자들을 어른이라 정의하였고 어른의 환자들만 활용하였다. 그 환자들의 첫번쨰 입원기록만을 사용하였고 그 이후에 입원한 기록은 사용하지 않았다. 이는 분석에 있어서 정보누출 가능성을 방지하고 related work와 유사한 실험 설정을 하기 위해서다.</p><h2 id="Data-extraction"><a href="#Data-extraction" class="headerlink" title="Data extraction"></a>Data extraction</h2><p>본 논문에서는 아래의 테이블을 사용하였다.</p><ul><li>inputevents(inputevents_cv, inputevents_mv): philips CareVue 시스템과 iMDSoft MetaVision 시스템을 사용하여 모니러링한 환자의 input 정보</li><li>ouputevents: ICU에 있는 동안 환자의 output 정보</li><li>chartevents: 환자에 대해 차트로 작성된 모든 정보</li><li>labevents: lab 정보</li><li>prescriptions: 환자에 처방된 정보, 처방받았으나 반드시 투여되는 것은 아님<br>본 연구에서 사용하는 데이터셋은 MIMIC-III와 MIMIC-III  (CareVue)이다.</li></ul><h2 id="Data-cleaning"><a href="#Data-cleaning" class="headerlink" title="Data cleaning"></a>Data cleaning</h2><ul><li><p>특정 변수의 unit들 불일치: 이를 해결하기 위해 변수별로 단위들의 비율을 구하였고 하나의 단위만 가지고 있을 경우는 그대로 두고 90% 이상이 차지하고 있는 unit을 major unit이라 정의하였는데 이 unit은 그대로 두고 나머지 unit들은 삭제하였다. 이외의 major unit(90% 이상을 차지하는 unit)가 없는 경우 <a href="https://www.drugs.com/dosage/">문헌</a>을 참고하여 하나의 unit으로 변환하였다. 변환된 unit은 논문의 Appendix A.6에 확인할 수 있다. 이 위의 것들에 해당되지 않는 feature의 경우 삭제하였다.</p>  <img src="/gallery/images/benchmarking-deep-learning-on-mimic/스크린샷 2021-05-13 오후 10.44.58.png" style="zoom:100%;" /></li><li><p>일부 변수에는 동시에 기록된 값들이 존재함: numerical feature들의 경우, average를 구했고 categorical feature의 경우, 첫번째로 나타난 값을 유지하였다.</p></li><li><p>일부 변수의 경우 범위로 기록되어있음: 범위의 median 값을 구하였다.</p></li></ul><h2 id="Feature-selection-and-extraction"><a href="#Feature-selection-and-extraction" class="headerlink" title="Feature selection and extraction"></a>Feature selection and extraction</h2><p>본 연구에서는 예측에 사용하기 위해 데이터셋에서 feature들을 추출하였고 철저한 비교를 위해 3가지의 features set을 선택하였다.</p><ul><li><p>feature set A는 SAPS-II의 계산에 사용되는 feature들로 구성된다. 이 feature들의 경우 의학 지식에 따라 outlier를 제거하고 관련 feature들을 병합하였다. 병합한 feature들은 논문에서 확인할 수 있다. 만성질병, 입원형태, 나이와 같은 feature들은 비시계열로 처리되었고 이외의 나머지는 시계열 feature들로 처리되었다.</p></li><li><p>feature set B는 SAPS-II에 사용되는 17개의 feature들과 관련있는 20개의 feature들로 구성되어있다. Feature set A를 얻기 위해 처리된 17개의 feature들 대신 원 상태의 값(raw value)을 고려한다. 이상치를 제거하지 않고 0미만의 값만 삭제하였다. <code>이 feature set은 raw value의 feature들의 성능을 연구하기 위해 구축되었다.</code></p></li><li><p>feature set C는 136개의 raw value들로 구성되며 feature set B의 feature들도 포함된다.  136개의 feature들은 2,000개의 feature들 중에 낮은 누락비율을 기반으로 선택되었다. Feature set B와 유사하게 전처리를 하지 않았으며 원 상태의 값을 사용했다. 이 feature set은 예측 모델이 대용량의 임상 시계열 데이터를 feature representation을 자동으로 학습할 수 있는지 동시에 더 좋은 성능을 나타낼 수 있는지 연구하기 위해 선택되었다.</p></li></ul><p>본 연구에서는 입원하고 첫 24시간과 첫 48시간 안에 수집된 feature들을 추출했으며 시계열 feature들의 경우 1시간마다 샘플링하였다. 샘플링 과정 중에 몇개의 feature들은 같은 시간안에 여러개의 판독값을 가진 경우, 평균 또는 합계를 구하였다. 일반적으로 수액 또는 약물에 대한 기록은 합계를 구하였고 이외의 다른 feature들은 평균을 구하였다. 결측값이 발생한 경우, 앞뒤의 값을 평균내서 imputation 하였다.</p><hr><h1 id="Benchmarking-experiments"><a href="#Benchmarking-experiments" class="headerlink" title="Benchmarking experiments"></a>Benchmarking experiments</h1><h2 id="Benchmark-prediction-tasks"><a href="#Benchmark-prediction-tasks" class="headerlink" title="Benchmark prediction tasks"></a>Benchmark prediction tasks</h2><ul><li><p>Mortality prediction(binary classification)<br>더 자세한 label 정의는 appendix A.2를 참고하세요.</p><ul><li>In-hospital mortality prediction: ICU에 입원 후 환자의 사망여부를 예측</li><li>Short-term mortality prediction: 2, 3일 안에 환자의 사망여부를 예측하며 첫 24시간 데이터의 경우 2, 3일 mortality를 예측할 수 있지만 48시간 데이터의 경우 3일 mortality를 예측할 수 있다.</li><li>Long-term mortality prediction: 첫 24시간, 48시간 데이터를 이용하여 30일, 1년 안에 환자의 사망여부를 예측    </li></ul></li><li><p>ICD-9 code group prediction(multi-task prediction)</p><p>ICD-9 diagnosis code를 예측하는 것이며, ICD 코드들은 다양한 증상, 징후,  부상이나 질병의 원인 등을 분류하는데 사용됩니다. 20개의 그룹으로 나뉘어져있다.<br>ICD-9 코드 그룹 760-779는 신생아에게 분류되는 코드이기 때문에 어른을 대상으로 하는 벤치마킹 연구에서 제외하였다.</p></li><li><p>Length of stay prediction(regression problem)<br>각 admission에 대한 입원 기간을 예측하였다.</p></li></ul><h2 id="Prediction-algorithms"><a href="#Prediction-algorithms" class="headerlink" title="Prediction algorithms"></a>Prediction algorithms</h2><h3 id="Scoring-methods"><a href="#Scoring-methods" class="headerlink" title="Scoring methods"></a>Scoring methods</h3><ul><li><p>SAPS-II : 이 점수는 ICU에 입원한 환자들 질병의 중증도 측정하기 위해 개발되었다. 12개의 feature들을 이용해 계산할 수 있다.  SAPS-II를 이용한 mortality 예측은 다음과 같다.</p><p>  $$<br>  log{\frac{p_{death}}{1-P_{death}}} = −7.7631 + 0.0737·S + 0.9971·log(1 + S)<br>  $$</p></li><li><p>SOFA: ICU에 입원한 환자들의 장기부전 및 예후 평가를 위한 점수이다. SOFA를 기반으로 한 mortality 예측은 로지스틱 회귀 모델을 사용하여 얻을 수 있다.</p></li><li><p>New SAPS-II: SAPS-II의 수정된 버전이며 SAPS-II에 사용된 feature들을 사용하여 로지스틱 회귀 모델을 사용하여 얻을 수 있다.</p></li></ul><h3 id="Super-Learner-models"><a href="#Super-Learner-models" class="headerlink" title="Super Learner models"></a>Super Learner models</h3><p>super learner는 예측 알고리즘의 최적의 조합을 찾기위해 개발된 supervised learning algorithm이며 cross-validation 이론을 기반으로 한다. 본 연구에서는 Super Learner I: 범주화된 변수들과의 super learner와 Super Learner II: 변환되지 않은 변수들의 super learner 두가지를 고려하였다. Super Learner-I는 feature set A만 적용되고 Super Learner-II는 feature set 3가지 모두 사용이 가능하다. </p><h3 id="Deep-Learning-models"><a href="#Deep-Learning-models" class="headerlink" title="Deep Learning models"></a>Deep Learning models</h3><p>딥러닝 모델은 end-to-end training을 위해 복잡한 데이터 representation을 자동으로 추출하는데 성공적인 접근 방식이다. 본 연구에서는 Feedforward neural networks(FFN)과 Recurrent Neural Network(RNN)의 ensemble인 Multimodal Deep Learning Model(MMDL)을 제안한다. 이 모델은 공유된 representation layer를 사용하여 modality들의 유사성을 학습하는 것이다. EHR과 같이 각 테이블 별로 별도의 modality를 가지는 데이터에 유용하다.</p><p>MMDL은 비시계열 데이터와 시계열 데이터를 개별적으로 다루는데 비시계열 데이터는 FFN에 시계열 데이터는 GRU에 input으로 들어가고 나온 ouput을 공유된 latent representaton layer에 combine한다.</p><h2 id="Implemetation-details"><a href="#Implemetation-details" class="headerlink" title="Implemetation details"></a>Implemetation details</h2><p>본 연구에서는 Theano와 Keras로 시행하였고 5-fold cross validation을 실시하였고 5개의 testing fold의 성능 점수의 평균과 표준 에러를 구하였다. 평가 metric으로classfication 문제의 경우 AUROC와 AUPRC를 사용하였고, regression 문제의 경우 MSE를 사용하였다. parameter 튜닝의 경우, 성능의 큰차이를 보이지 않아 각 알고리즘의 기본 hyper parameter를 세팅하였다.</p><p>딥러닝 모델에서는 learning rate는 classificaton 문제는  0.001, regression 문제는 0.005로 두었고 RMSProp optimizer로 train하였다. activation function은 ReLU를 사용하였고 dropout rate은 0.1, batch sizesms 100, max epoch number는 250으로 세팅하였고 early stopping을 사용해서 최적의 weight를 구하고 batch normalization을 사용하였다. 위에서 언급했듯이 비시계열 데이터는 FFN, 시계열 데이터는 GRU로 다뤘다.</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>대부분의 예측 결과 MMDL의 성능이 더 좋았다는 것을 얘기하고 있고 feature들 중에서는 전처리를 하지 않고 다른 feature set들보다 많은 수의 feature들을 가진 feature set C가 더 좋은 점수를 얻었다. 따라서 본 연구에서는 원본의 임상 시계열 데이터가  예측 모델의 input feature로 사용되는 경우, 딥러닝 모델이 머신러닝 앙상블, SAPS II와 SOFA 점수를 이용한 예측보다 성능이 우수하다는 것을 보여준다.</p><hr><h1 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h1><p><a href="https://www.sciencedirect.com/science/article/pii/S1532046418300716">Benchmarking deep learning models on large healthcare datasets</a></p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/DEEP-LEARNING/">DEEP LEARNING</category>
      
      <category domain="https://rimiiii.github.io/categories/DEEP-LEARNING/HEALTHCARE/">HEALTHCARE</category>
      
      
      <category domain="https://rimiiii.github.io/tags/MIMIC/">MIMIC</category>
      
      <category domain="https://rimiiii.github.io/tags/detection/">detection</category>
      
      
      <comments>https://rimiiii.github.io/2021/06/15/benchmarking-deep-learning-on-healthcare-datasets/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[삽질기록] Error: unknown format: 65534</title>
      <link>https://rimiiii.github.io/2021/06/11/error1/</link>
      <guid>https://rimiiii.github.io/2021/06/11/error1/</guid>
      <pubDate>Fri, 11 Jun 2021 05:16:32 GMT</pubDate>
      
      <description>&lt;p&gt;wav file을 split한 파일을 받아 google speech recognition을 돌리는 중에 에러가 발생했다. 이 파일은 &lt;code&gt;librosa로는 읽혀지지만 wave로는 읽혀지지 않아서 의아했다&lt;/code&gt;. speech_recognition module에서 에러가 난거지만 그 안의 함수들도 함께 에러가 난거여서 원인을 찾는 것이 생각보다 어려웠다..일주일 걸렸다..ㅠ&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>wav file을 split한 파일을 받아 google speech recognition을 돌리는 중에 에러가 발생했다. 이 파일은 <code>librosa로는 읽혀지지만 wave로는 읽혀지지 않아서 의아했다</code>. speech_recognition module에서 에러가 난거지만 그 안의 함수들도 함께 에러가 난거여서 원인을 찾는 것이 생각보다 어려웠다..일주일 걸렸다..ㅠ</p><span id="more"></span><h1 id="에러-화면"><a href="#에러-화면" class="headerlink" title="에러 화면"></a>에러 화면</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: unknown <span class="built_in">format</span>: <span class="number">65534</span></span><br><span class="line">Error: file does <span class="keyword">not</span> start <span class="keyword">with</span> FORM <span class="built_in">id</span></span><br><span class="line">ValueError: Audio file could <span class="keyword">not</span> be read <span class="keyword">as</span> PCM WAV, AIFF/AIFF-C, <span class="keyword">or</span> Native FLAC; check <span class="keyword">if</span> file <span class="keyword">is</span> corrupted <span class="keyword">or</span> <span class="keyword">in</span> another <span class="built_in">format</span></span><br></pre></td></tr></table></figure><p>원인은 자른 파일의 포맷 문제였다. wav 파일 안에도 pcm 포맷을 포함하고 있는데 wav 파일을 잘라내는 과정에서 포맷이 wav 인코딩 중 하나인 pcm으로 변경된 것이다(다만, 확장자명은 wav..😭). 그래서 pcm을 wav 파일로 변환하면 문제가 해결된다!!</p><h1 id="변환-파일코드"><a href="#변환-파일코드" class="headerlink" title="변환 파일코드"></a>변환 파일코드</h1><p>어떤 자상한 분이 코드를 직접 짜주셔서 그대로 가져왔다. 출처는 아래에</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="comment"># The parameters are prerequisite information. More specifically,</span></span><br><span class="line"><span class="comment"># channels, bit_depth, sampling_rate must be known to use this function.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pcm2wav</span>(<span class="params"> pcm_file, wav_file, channels=<span class="number">1</span>, bit_depth=<span class="number">16</span>, sampling_rate=<span class="number">16000</span> </span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check if the options are valid.</span></span><br><span class="line">    <span class="keyword">if</span> bit_depth % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;bit_depth &quot;</span>+<span class="built_in">str</span>(bit_depth)+<span class="string">&quot; must be a multiple of 8.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Read the .pcm file as a binary file and store the data to pcm_data</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>( pcm_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> opened_pcm_file:</span><br><span class="line">        pcm_data = opened_pcm_file.read();</span><br><span class="line">        </span><br><span class="line">        obj2write = wave.<span class="built_in">open</span>( wav_file, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        obj2write.setnchannels( channels )</span><br><span class="line">        obj2write.setsampwidth( bit_depth // <span class="number">8</span> )</span><br><span class="line">        obj2write.setframerate( sampling_rate )</span><br><span class="line">        obj2write.writeframes( pcm_data )</span><br><span class="line">        obj2write.close()</span><br><span class="line"></span><br><span class="line">pcm2wav( <span class="string">&#x27;sample_001.pcm&#x27;</span>, <span class="string">&#x27;sample_001.wav&#x27;</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">16000</span> )</span><br></pre></td></tr></table></figure><h1 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h1><p><a href="https://m.blog.naver.com/PostView.nhn?blogId=aimldl&logNo=221559323232&proxyReferer=https://www.google.com/">pcm2wav.py</a></p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/PYTHON/">PYTHON</category>
      
      <category domain="https://rimiiii.github.io/categories/PYTHON/BUG-FIX/">BUG FIX</category>
      
      
      <category domain="https://rimiiii.github.io/tags/error/">error</category>
      
      <category domain="https://rimiiii.github.io/tags/ppm/">ppm</category>
      
      
      <comments>https://rimiiii.github.io/2021/06/11/error1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[책을 읽고] 미드나잇 라이브러리</title>
      <link>https://rimiiii.github.io/2021/06/09/midnight-library/</link>
      <guid>https://rimiiii.github.io/2021/06/09/midnight-library/</guid>
      <pubDate>Wed, 09 Jun 2021 05:25:29 GMT</pubDate>
      
      <description>&lt;p&gt;서점에 갔다가 별 생각 없이 집어든 책이 나에게 엄청 큰 행복과 깨달음을 주었다. 현재의 삶에 자신이 없고 후회하는 사람들에게 추천하는 책📚 &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>서점에 갔다가 별 생각 없이 집어든 책이 나에게 엄청 큰 행복과 깨달음을 주었다. 현재의 삶에 자신이 없고 후회하는 사람들에게 추천하는 책📚 </p><span id="more"></span><p>제일 중요한 것은 무엇을 보느냐가 아니라 어떨게 보느냐다. 내가 후회하던 것들을 다른 우주의 나는 행동했을거고 그 우주 속의 나는 나와는 같으면서도 다른 나일 것이다. 결국 나는 유일한 이 우주 속의 나이기 때문에 내 삶을 소중하게 여기고 나 스스로를 돌봐야한다.</p><h1 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h1><p>그저 그런 삶을 살고 있던 노라는 자신의 고양이인 볼테르가 죽고나서 자신도 죽음을 택한다. 삶과 죽음 사이에 있는 도서관이는 자신의 학창시절 사서 선생님이였던 엘름주인이 계셨다. 도서관의 책을 펼치면 직각 인생을 살 수 있다고 한다. </p><p>노라는 댄과 헤어진 것을 후회하고 있고 그 후회를 되돌리는 책을 펼쳤다. 그 삶 속에서의 노라는 행복하지 않았다. 댄은 바람을 폈고 술도 많이 마셨다. 노라가 기억하지 못했던 댄의 모습들이었다. 실망하는 순간 다시 자정의 도서관으로 돌아갔다. </p><p>노라는 이지를 따라가지 않은 것을 후회하고 있었고 이지를 따라가나는 삶을 펼쳐보았으나 그 곳에서 이지는 죽은 뒤었다. 그 다음은 아빠의 바람이었던 수영선수의 꿈을 포기하지 않는 삶을 펼쳐보았으나 그곳에선 아빠가 바람을 폈고 노라가 수영을 하느라 돌보지 못한 엄마는 일찍 생을 마감하였다.  </p><p>빙하학자의 삶을 살아본 노라는 자신이 결정한 삶의 마감이 아닌 다른 누군가(곰)의 결정이 될 뻔했을때 살고싶다는 욕구를 느꼈다. 이 삶으로 인해 부모님을 용서하게 된다. </p><p>빙하학자의 삶을 살고 있을때 노라와 같은 현상을 겪는 사람을 만났다. 그리 오래 대화하지는 못했지만. 그 다음 삶은 음악을 계속하는 것. 그 삶 속에서는 노라가 팬인 라이언 베일리와 짧게나마 연인 사이였고 그리 마음에 드는 상대는 아니었다. 노라는 트위터에 이런 글을 남겼다. “모든 것을 가지고도 아무 느낌이 없을 수 있다.“ </p><p>성공한 셀럽의 삶 속에서는 노라의 오빠가 약물 과다복용으로 사망한지 2년이 지난 후였고 노라가 다른 삶을 그만 살고 싶어할 때 엘름 부인은 체스판의 보잘것 없는 폰처럼 그저 앞으로 나아가라고 한다. 끝에 도달으면 다른 기물로 승급할 수 있다며. 노라는 남이 아닌 자신이 원하는 삶을 살아보고 싶어했다. </p><p>동물 보호소에서 일을 하는 삶 속에서의 노라를 살아봤으나 그 속에 있던 딜런(남자친구)을 그 삶을 살고 있던 노라에게 다시 돌려주고 싶었고 그 삶에서 떠났다. 그 다음 삶은 부부의 삶이였으나 뭐랄까.. 그저 그런 침묵들이 있는 삶이었고 노라는 바로 도서관으로 돌아갔다. </p><p>노라는 고양이 볼테르의 죽음을 알리러 온 애쉬의 호의를 수락하는 삶을 살게 됐다. 딸아이가 있었고 행복하고 완벽한 삶이었다. 그치만 이 삶이 자신의 삶이 아니라는 걸 알고 있었고 그 사실을 잊고 싶었다. </p><p>노라는 결국 다시 자정의 도서관으로 돌아갔다. 도서관은 무너지고 있었고 노라는 원래 자신의 삶으로 돌아가고 싶었다. 살아있고 싶었다. 원래의 삶으로 돌아간 노라는 모든게 달라졌다. 노라는 삶을 다르게 보고 있었다. 인간은 무한하다. 살아있는 동안 우리는 늘 다양한 가능성의 미래를 품고 있다. 노라가 소중하게 여긴 사람들을 만났고 애쉬에게도 어쩌면 커피한잔하자고 말할 수 있다. </p><h1 id="좋았던-구절들"><a href="#좋았던-구절들" class="headerlink" title="좋았던 구절들"></a>좋았던 구절들</h1><p>p56 SNS에 할애한 시간이 후회돼. 어릴 때 더 많이 놀지 못한 게 후회돼. 더 행복한 사람이 되는 법을 배우지 못한 게 후회돼. 죄책감을 너무 많이 느낀 게 후회돼. 꾸준히 건강 관리를 하지 않은 게 후회돼.</p><p>p74 사람은 도시와 같아서 마음에 덜 드는 부분이 몇 개 있다고 해서 전체를 거부할 순 없다. 위험해보이는 골목길이나 교외 등 마음에 안 드는 부분이 있을지라도 다른 장점이 그 도시를 가치 있게 만들어준다.</p><p>p92 “예측하기 힘들지? 무엇이 우리를 행복하게 해줄지 말이야.”</p><p>p187 “인간은 150명의 사람만 알고 지내도록 만들어졌어요. 인스타그램을 한 시간만 해도 150명은 만날 수 있어요. 건강하지 않아요! 뇌가 감당하지 못합니다. 그래서 우리가 그 어느 때보다 대면 소통을 갈망하는 거죠.”</p><p>p266 “다른 사람에게 상처를 주지 않고서는 살 수가 없는 것 같아요.” “원래 인생은 그런 거야”</p><p>p301 와인을 만들어 파는 부부의 이야기 -&gt; 이 삶 속에서는 이미 행복했던 순간(예를 들면, 아이를 키우는 일, 같이 목표를 이루는 일 등)들이 다 지나갔고 물론 지금 삶이 행복하지 않은 건 아니겠지만 그런 삶들이 있으니까 침묵 속에서도 평화로운게 아닐까?</p><p>p318 몇 년이나 놓쳐버린 삶에 어떻게 그냥 끼어들 수 있을까? 노라는 눈을 감았다. 다른 삶에서도 아이가 있었던 적이 있기는 했지만 모두 1, 2분 내로 끝나버렸다.</p><p>p361 노라가 한 일이라고 해봐야 인터넷 쇼핑몰을 깔아주고, 약국에서 약을 서너 번 타다 준것이 전부였다. 절대 사소한 것의 중요성을 과소평가하지 말라고 엘름 부인은 말했다. 그 말을 늘 명심해야 한다고.</p><h1 id="좋은-구절들"><a href="#좋은-구절들" class="headerlink" title="좋은 구절들"></a>좋은 구절들</h1><p>p67 참된 앎이란 자신의 무지를 아는 것이다. - 소크라테스(가 우리 펍의 퀴즈 게임에서 지고 난 후에 한 말!!!!)</p><p>p96 살아봐야만 배울 수 있다.</p><p>p127 “사소한 것의 중요성을 절대 과소평가하지 마라. 그 말을 늘 명심해야 해” -&gt; 나한테도 그냥 책을 사서 읽는 게 사소한 일이었는데 가끔은 엄청 소중하게 느껴진다.</p><p>p138 “내가 아닌 다른 사람이 되는 걸 목표로 한다면 반드시 실패합니다. 나 자신이 되는 걸 목표로 하세요. 나처럼 보이고 행동하고 생각하는 걸 목표로 하세요. 가장 ‘나다운 나’가 되는 걸 목표로 하세요. 나를 나로 만드는 모든 요소를 받아들이세요. 그걸 지지하세요. 사랑하세요. 갈고닦으세요. 사람들이 그걸 조롱하고 비웃을 때 휩쓸리지 마세요. 대부분의 험담은 사실 질투랍니다. 묵묵히 할 일을 하세요.”</p><p>p199 하지만 어쩌면 모든 삶이 다 그럴지 모른다. 겉보기에는 아주 흥미진진하거나 가치 있어 보이는 삶조차 결국에는 그런 기분이 들지 모른다. 실망과 단조로움과 마음의 상처와 경쟁만 한가득이고, 아름답고 경이로운 경험은 순간에 끝난다.</p><p>p219 내가 원하는 어떤 삶이든 살 수 있다는 걸 기억해야 합니다. 어떤 삶이든요. 꿈을 크게 가져요……. 당신은 원하는 건 무엇이든 될 수 있습니다. 그렇게 사는 삶이 존재하니까요.”</p><p>p258 매일 매 순간 우리는 새로운 우주로 들어가요. 자신을 타인 그리고 또 다른 자신과 비교하며 삶이 달라지기를 바라는 데 많은 시간을 보내죠. 사실 대부분의 삶에는 좋은 일과 나쁜 일이 공존하는데 말이에요.”<br>“한 삶에만 갇혀 있는 동안에는 슬픔이나 비극 혹은 실패나 두려움이 그 삶을 산 결과라고 생각하기 쉽죠. 그런 것들은 단순히 삶의 부산물일 뿐인데 우리는 그게 특정한 방식으로 살았기 때문에 생겨났다고 생각해요. 하지만 슬픔이 없는 삶은 없다는 걸 이해하면 사는 게 훨씬 쉬어질 거에요. 슬픔은 본질적으로 행복의 일부라는 사실도요. 슬픔 없이 행복을 얻을 수는 없어요. 물론 사람마다 그 정도돠 양이 다르긴 하겠죠. 하지만 영원히 순수한 행복에만 머물 수 있는 삶은 없어요. 그런 삶이 있다고 생각하면, 현재의 삶이 더 불행해지게 느껴질 뿐이요.”</p><p>p269 “경기는 끝날 때까지 끝난 게 아니야. 넌 그걸 깨달아야 해. 체스판에 폰이 하나라도 남아 있으면 경기는 끝난 게 아니야. 한 사람은 폰 하나와 킹 하나만 남고, 다른 사람은 기물이 다 있어도 경기는 아직 진행 중인 거야. 설사 네가 폰이라고 해도, 아마 우리 모두 그럴테지만, 넌 폰이 가장 마법 같은 기물이라는 사실을 기억해야 해. 폰은 하찮고 평범해 보이지만 사실은 그렇지 않아. 왜나하면 폰은 절대 그냥 폰이 아니니까. 폰은 차기 퀸이야. 넌 그저 계속 앞으로 나아갈 방법만 찾으면 돼. 한 칸 한 칸 앞으로 나아가는 거야. 그러다 반대편 끝에 도달하면 얼마든지 다른 기물로 승급할 수 있어.”</p><p>p313 “우리가 경험하는 모든 것은 결국 그것에 대한 우리의 인식일 뿐이야. ‘중요한 건 무엇을 보느냐가 아니라 어떻게 보느냐’지.”</p><p>p299 “있잖아, 오빠. 인생은 이해하는 게 아니야. 그냥 사는 거야.”</p><p>행동하고 싶은 구절들<br>p275 “하지만 형제나 남매간의 경쟁은 당사자들보다 부모 때문이라고들 하죠. 전 늘 부모님이 오빠의 꿈을 좀 더 응원한다고 느꼈어요.” </p><p>p353 이번 삶에서도 부모님은 돌아가셨지만 그녀에게는 몰리가 있었고, 애쉬가 있었고, 조가 있었다. 그녀가 추락하지 않게 받쳐주는 사랑의 그물망이 있었다. </p><p>p384 그녀가 가진 단 하나의 진실이자, 이제는 너무나 자랑스럽고 기쁜 진실, 타협하게 되었을 뿐 아니라 온몸의 세포 하나하나가 대놓고 환영하는 진실이었따. 노라는 그 진실을 서둘러, 하지만 종이 위로 펜촉을 꾹꾹 눌러가면서 확실히 적었따. 대문자, 일인칭 현재 시제로.<br>그녀에게 가능한 모든 인생의 씨앗이자 시작인 진실. 예전에는 저주였으나 이제는 축복이 된 진실.<br>다중 우주의 잠재력과 힘이 간직한 간단한 문장이었다.<br>나는 살아 있다.</p><p>p392 우리는 한 사람이기만 하면 된다. 한 존재만 느끼면 된다. 모든 것이 되기 위해 모든 일을 할 필요는 없다. 왜냐하면 우리는 이미 무한하기 때문이다. 살아 있는 동안 우리는 늘 다양한 가능성의 미래를 품고 있다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/REVIEW/">REVIEW</category>
      
      <category domain="https://rimiiii.github.io/categories/REVIEW/BOOK/">BOOK</category>
      
      
      <category domain="https://rimiiii.github.io/tags/book/">book</category>
      
      <category domain="https://rimiiii.github.io/tags/review/">review</category>
      
      
      <comments>https://rimiiii.github.io/2021/06/09/midnight-library/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 1065번 한수</title>
      <link>https://rimiiii.github.io/2021/05/27/baekjoon7/</link>
      <guid>https://rimiiii.github.io/2021/05/27/baekjoon7/</guid>
      <pubDate>Thu, 27 May 2021 14:12:29 GMT</pubDate>
      
      <description>&lt;p&gt;어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.</p><span id="more"></span><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>()) </span><br><span class="line"><span class="keyword">if</span> N &lt;= <span class="number">99</span>: </span><br><span class="line">    <span class="built_in">print</span>(N) </span><br><span class="line"><span class="keyword">else</span>: count = <span class="number">99</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, N+<span class="number">1</span>): </span><br><span class="line">    fst_value = <span class="built_in">int</span>(<span class="built_in">str</span>(i)[<span class="number">1</span>]) - <span class="built_in">int</span>(<span class="built_in">str</span>(i)[<span class="number">0</span>]) </span><br><span class="line">    sec_value = <span class="built_in">int</span>(<span class="built_in">str</span>(i)[<span class="number">2</span>]) - <span class="built_in">int</span>(<span class="built_in">str</span>(i)[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">if</span> fst_value == sec_value: </span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">pass</span> </span><br><span class="line"><span class="built_in">print</span>(count) </span><br></pre></td></tr></table></figure><p>이 문제는 풀이는 어렵지 않으나 문제의 뜻을 이해 못했다..문제의 뜻을 설명하자면 숫자 자체가 등차수열로 이루어져있는 것들만 찾는 것이다. 예를 들면, 135처럼 2를 공차로 둔 것이다. 99까지는 당연히 2개의 숫자로 이루어져있기 때문에 등차수열로 이루어져있는 한수이다. 그래서 99 이전의 숫자인 경우는 숫자 그자체가 한수의 갯수가 된다. 100이 넘어가는 숫자들부터는 백의자리 숫자와 십의자리 숫자를 뺀 값과 십의자리 숫자와 일의자리 숫자를 뺀 값이 같은 경우의 숫자들만 count하였다. 덧붙이자면 이 값이 공차가 된다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://rimiiii.github.io/tags/python/">python</category>
      
      
      <comments>https://rimiiii.github.io/2021/05/27/baekjoon7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 4673번 셀프 넘버</title>
      <link>https://rimiiii.github.io/2021/05/27/baekjoon5/</link>
      <guid>https://rimiiii.github.io/2021/05/27/baekjoon5/</guid>
      <pubDate>Thu, 27 May 2021 12:06:29 GMT</pubDate>
      
      <description>&lt;p&gt;10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.</p><span id="more"></span><p>셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), …과 같은 무한 수열을 만들 수 있다. 예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다. 33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, … n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97</p><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>입력은 없다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">original_set = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10001</span>))</span><br><span class="line">generated_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10001</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">str</span>(i):</span><br><span class="line">    i += <span class="built_in">int</span>(j)</span><br><span class="line">  generated_set.add(i)</span><br><span class="line"></span><br><span class="line">self_num = <span class="built_in">sorted</span>(original_set - generated_set)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> self_num:</span><br><span class="line">  <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>숫자들의 각각의 자릿수를 끄집어내는 것은 str을 이용할 수 있다. 예를 들어 33이라면 str(33)으로 ‘33’으로 string 형태로 만든 뒤 for문을 이용하면 하나의 숫자씩 끄집어내는 것이 가능하다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://rimiiii.github.io/tags/python/">python</category>
      
      
      <comments>https://rimiiii.github.io/2021/05/27/baekjoon5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 10818번 최소, 최대</title>
      <link>https://rimiiii.github.io/2021/05/27/baekjoon6/</link>
      <guid>https://rimiiii.github.io/2021/05/27/baekjoon6/</guid>
      <pubDate>Thu, 27 May 2021 12:06:29 GMT</pubDate>
      
      <description>&lt;p&gt;N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.</p><span id="more"></span><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">number_list = sys.stdin.readline().split()</span><br><span class="line">number_int = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> number_list:</span><br><span class="line">    number_int.append(<span class="built_in">int</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(number_int), <span class="built_in">max</span>(number_int))</span><br></pre></td></tr></table></figure><p>2번의 시도를 했을때 런타임 에러가 나왔는데 이럴땐 sys.stdin.readline()을 이용해서 빠르게 불러오면 해결할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://rimiiii.github.io/tags/python/">python</category>
      
      
      <comments>https://rimiiii.github.io/2021/05/27/baekjoon6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>#1. EHR 데이터를 이용한 이벤트 예측 프로젝트</title>
      <link>https://rimiiii.github.io/2021/05/11/event-prediction/</link>
      <guid>https://rimiiii.github.io/2021/05/11/event-prediction/</guid>
      <pubDate>Tue, 11 May 2021 14:16:29 GMT</pubDate>
      
      <description>&lt;p&gt;EHR 데이터를 이용하여 이벤트를 예측하는 프로젝트를 진행하려합니다. 사용할 데이터는 ICU 데이터이며 오픈소스인 &lt;code&gt;MIMIC3&lt;/code&gt;입니다. 어떤 이벤트를 예측할지 아직 고민중이고 우선적으로 MIMIC3의 주요 컬럼들을 리뷰하였습니다. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>EHR 데이터를 이용하여 이벤트를 예측하는 프로젝트를 진행하려합니다. 사용할 데이터는 ICU 데이터이며 오픈소스인 <code>MIMIC3</code>입니다. 어떤 이벤트를 예측할지 아직 고민중이고 우선적으로 MIMIC3의 주요 컬럼들을 리뷰하였습니다. </p><span id="more"></span><p>이 컬럼들 중에서 필요한 것들과 그렇지 않은 것들을 걸러내야되고 어떤 이벤트를 예측할지는 논문을 읽으며 결정할 것입니다. MIMIC3의 주요 컬럼들은 아래와 같습니다. 의료 도메인이 아니기 때문에 이해가 안가는 컬럼들과 잘못 해석한 것들이 있을 수 있습니다. 혹시나 첨언해주실 분이 있으면 정말 감사하겠습니다😆</p><p>MIMIC 데이터베이스 문서 링크: <a href="https://mimic.physionet.org/about/mimic/">https://mimic.physionet.org/about/mimic/</a></p><h1 id="MIMIC3-주요-컬럼-리뷰"><a href="#MIMIC3-주요-컬럼-리뷰" class="headerlink" title="MIMIC3 주요 컬럼 리뷰"></a>MIMIC3 주요 컬럼 리뷰</h1><h2 id="ADMISSION"><a href="#ADMISSION" class="headerlink" title="ADMISSION"></a>ADMISSION</h2><ul><li>ROW_ID</li><li>SUBJECT_ID: PATIENTS 테이블과 연결할 수 있는 key값</li><li>HADM_ID: key값</li><li>ADMITTIME: 환자가 병원에서 입원한 날짜와 시간</li><li>DISCHTIME: 환자가 병원에서 퇴원한 날짜와 시간</li><li>DEATHTIME: 환자가 사망했을 경우 사망 날짜와 시간</li><li>ADMISSION_TYPE(urgent랑 emergency랑 뭐가 다름?)</li><li>ELECTIVE: 계획된 입원</li><li>URGENT: 긴급 입원</li><li>NEWBORN: 출생</li><li>EMERGENCY: 응급</li><li>INSURANCE: 보험 청구</li><li>private</li><li>medicare</li><li>EDREGTIME: emergency department에서 등록된 시간</li><li>EDOUTTIME: emergency department에서 퇴원한 시간</li><li>DIAGNOSIS: 진단</li><li>HOSPITAL_EXPIRE_FLAG: 사망했을 경우 1, 생존했을 경우 0</li><li>HAS_CHARTEVENTS_DATA</li></ul><h2 id="D-ICD-DIAGNOSES"><a href="#D-ICD-DIAGNOSES" class="headerlink" title="D_ICD_DIAGNOSES"></a>D_ICD_DIAGNOSES</h2><p>ICD9 진단코드</p><ul><li>ROW_ID</li><li>ICD9_CODE</li><li>SHORT_TITLE</li><li>LONG_TITLE</li></ul><h2 id="D-ICD-PROCEDURES"><a href="#D-ICD-PROCEDURES" class="headerlink" title="D_ICD_PROCEDURES"></a>D_ICD_PROCEDURES</h2><p>ICD9 처치코드</p><ul><li>ROW_ID</li><li>ICD9_CODE</li><li>SHORT_TITLE</li><li>LONG_TITLE</li></ul><h2 id="D-ITEMS"><a href="#D-ITEMS" class="headerlink" title="D_ITEMS"></a>D_ITEMS</h2><p>ICU 데이터베이스 안의 모든 아이템 정의. 2개의 다른 ICU 데이터베이스들이 합쳐지면서 같은 의미지만 다른 이름으로 쓰이는 것들이 존재함. 결과적으로 ITEMID는 다르지만 하나의 concept(LABEL)로 되어있다.<br>LINKSTO가 null값인 경우는 현재 이용불가능한 데이터이며 release될 예정이다.</p><ul><li>ROW_ID</li><li>ITEMID</li><li>LABEL: ITEMID로부터 재정의된 concept</li><li>ABBREVIATION: label의 약자, metavision인 경우에만 이용가능함</li><li>DBSOURCE</li><li>carevue</li><li>metavision</li><li>hospital</li><li>CATEGORY: ITEMID가 해당하는 데이터 유형, 예를 들어 ABG의 경우 정맥 주사를 하기 때문에 IV Medication</li><li>UNITNAME: ITEMID의 측정단위</li><li>PARAM_TYPE: 기록된 데이터의 타입(날짜, 숫자, 텍스트 등)</li><li>CONCEPTID</li></ul><h2 id="D-LABITEMS"><a href="#D-LABITEMS" class="headerlink" title="D_LABITEMS"></a>D_LABITEMS</h2><p>Labitem 정보들</p><ul><li>ROW_ID</li><li>ITEM_ID</li><li>LABEL</li><li>FLUID: 액체 카테고리로 보임(복수, 뇌척수액 등)</li><li>CATEGORY: 검사종류(hematology, blood gas, chemistry)</li><li>LOINC_CODE</li></ul><h2 id="DIAGNOSES-ICD"><a href="#DIAGNOSES-ICD" class="headerlink" title="DIAGNOSES_ICD"></a>DIAGNOSES_ICD</h2><p>ICD9 기반</p><ul><li>SUBJECT_ID: 환자 ID</li><li>HADM_ID: 환자입원 ID</li><li>SEQ_NUM: 질병 우선순위 순서</li></ul><h2 id="DRGCODES"><a href="#DRGCODES" class="headerlink" title="DRGCODES"></a>DRGCODES</h2><p>입원ID별로 심각성을 알 수 있음<br>진단 관련 그룹 코드, 포괄수가제(입원해서 퇴원할 때까지 발생하는 진료에 대해 질병마다 미리 정해진 금액을 내는 제도)</p><ul><li>DRG_TYPE: HCFA/MS/APR</li><li>DRG_CODE: 진단 금액 코드</li><li>DESCRIPTION: drg code 요약글</li><li>DRG_SEVERITY: drg 심각성, 심각한 경우 더 높은 청구 비용을 허용함</li><li>DRG_MORTALITY: 사망률</li></ul><h2 id="LABEVENTS"><a href="#LABEVENTS" class="headerlink" title="LABEVENTS"></a>LABEVENTS</h2><p>measurements기반의 laboratory 데이터</p><ul><li>SUBJECT_ID</li><li>HADM_ID</li><li>ITEM_ID</li><li>CHARTTIME</li><li>VALUE: measure값</li><li>VALUENUM: value가 numeric인 경우 numeric format으로 기재되어있음</li><li>VALUEUOM: value의 단위</li><li>FLAG: value가 abnormal인지 아닌지(delta가 무슨의미인지 확인할것)</li></ul><h2 id="MICROBIOLOGYEVENTS"><a href="#MICROBIOLOGYEVENTS" class="headerlink" title="MICROBIOLOGYEVENTS"></a>MICROBIOLOGYEVENTS</h2><p>미생물학정보<br>ABTEST: a: control, b: treatment</p><ul><li>SUBJECT_ID</li><li>HADM_ID</li><li>CHARTDATE: 차트날짜</li><li>CHARTTIME: 차트날짜+시간</li><li>SPEC_ITEMID: specimen itemid</li><li>SPEC_TYPE_DESC</li><li>ORG_ITEM_ID</li><li>ORG_NAME: 조직이름</li><li>ISOLATE_NUM</li><li>AB_ITEMID</li><li>AB_NAME</li><li>DILUTION_TEXT: 비교정보 텍스트</li><li>DILUTION_COMPARISON</li><li>DILUTION_VALUE</li><li>INTERPRETATION</li></ul><h2 id="PATIENTS"><a href="#PATIENTS" class="headerlink" title="PATIENTS"></a>PATIENTS</h2><ul><li>SUBJECT_ID</li><li>GENDER</li><li>DOB: date of birth</li><li>DOD: date of death</li><li>DOD_HOSP: 병원에서 기록된 사망 날짜</li><li>DOD_SSN: social security database에서 기록된 사망 날짜</li><li>EXPIRE_FLAG: 사망했을 경우 1, 아닐 경우 0</li></ul><h2 id="PRESCRIPTIONS"><a href="#PRESCRIPTIONS" class="headerlink" title="PRESCRIPTIONS"></a>PRESCRIPTIONS</h2><ul><li>ROW_ID</li><li>SUBJECT_ID</li><li>HADM_ID</li><li>ICUSTAY_ID</li><li>STARTDATE</li><li>ENDDATE</li><li>DRUG_TYPE: MAIN, BASE, ADDITIVE가 있음</li><li>DRUG_NAME</li><li>DRUG_NAME_POE: DRUG_NAME과 같거나 nan이거나</li><li>DRUG_NAME_GENERIC</li><li>FORMULARY_DRUG_CD, GSN, NDC: 다른 drug code</li><li>GSN: Generic Sequence Number</li><li>NDC: National Drug Code</li><li>PROD_STRENGTH: 약물의 단위별 용량</li><li>DOSE_VAL_RX: 처방한 용량 값</li><li>DOSE_UNIT_RX: 처방한 용량 단위</li><li>FORM_VAL_DISP: 처방된 용량을 맞추기 위해 처방된 갯수</li><li>FROM_UNIT_DISP</li><li>ROUTE: 약물이 들어가는 루트</li><li>PROD_STRENGH * FORM_VAL_DISP  = DOSE_VAL_RX</li></ul><h2 id="PROCEDUREEVENTS-MV"><a href="#PROCEDUREEVENTS-MV" class="headerlink" title="PROCEDUREEVENTS_MV"></a>PROCEDUREEVENTS_MV</h2><p>설명이 없음..procedure가 metavision인 경우 이곳에 추가 데이터가 저장되어있는 것으로 보임</p><ul><li>ROW_ID</li><li>SUBJECT_ID</li><li>HADM_ID</li><li>ICUSTAY_ID</li><li>STARTTIME</li><li>ENDTIME</li><li>ITEMID</li><li>VALUE</li><li>VALUEUOM</li><li>LOCATION</li><li>LOCATIONCATEGORY</li><li>STORETIME</li><li>CGID</li><li>ORDERID</li><li>LINKORDERID</li><li>ORDER CATEGORY NAME</li><li>SECONDARY ORDER CATEROY NANE</li><li>ORDER CATEGORY DESCRIPTION</li><li>ISOPENBAG</li><li>CONTINUE IN NEXT DEPT</li><li>CANCEL REASON</li><li>STATUS DESCRIPTION</li><li>COMMENTS_DITDBY</li><li>COMMENTS_CANCELEDBY</li><li>COMMENTS_DATE</li></ul><h2 id="PROCEDURES-ICD"><a href="#PROCEDURES-ICD" class="headerlink" title="PROCEDURES_ICD"></a>PROCEDURES_ICD</h2><ul><li>SUBJECT_ID</li><li>HADM_ID</li><li>SEQ_NUM: 우선순위</li><li>ICD9_CODE: procedure code, D_ICD_PROCEDURES와 join 가능</li></ul>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/DEEP-LEARNING/">DEEP LEARNING</category>
      
      <category domain="https://rimiiii.github.io/categories/DEEP-LEARNING/HEALTHCARE/">HEALTHCARE</category>
      
      
      <category domain="https://rimiiii.github.io/tags/ehr/">ehr</category>
      
      <category domain="https://rimiiii.github.io/tags/prediction/">prediction</category>
      
      
      <comments>https://rimiiii.github.io/2021/05/11/event-prediction/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 4344번 평균은 넘겠지</title>
      <link>https://rimiiii.github.io/2021/05/06/baekjoon4/</link>
      <guid>https://rimiiii.github.io/2021/05/06/baekjoon4/</guid>
      <pubDate>Thu, 06 May 2021 14:22:29 GMT</pubDate>
      
      <description>&lt;p&gt;대학생 새내기들의 90%는 자신이 반에서 평균은 넘는다고 생각한다. 당신은 그들에게 슬픈 진실을 알려줘야 한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>대학생 새내기들의 90%는 자신이 반에서 평균은 넘는다고 생각한다. 당신은 그들에게 슬픈 진실을 알려줘야 한다.</p><span id="more"></span><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>첫째 줄에는 테스트 케이스의 개수 C가 주어진다. 둘째 줄부터 각 테스트 케이스마다 학생의 수 N(1 ≤ N ≤ 1000, N은 정수)이 첫 수로 주어지고, 이어서 N명의 점수가 주어진다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다.</p><h1 id="문제풀이"><a href="#문제풀이" class="headerlink" title="문제풀이"></a>문제풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(C):</span><br><span class="line">  N_scores = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">  N = N_scores[<span class="number">0</span>]</span><br><span class="line">  scores = N_scores[<span class="number">1</span>:]</span><br><span class="line">  average = <span class="built_in">sum</span>(scores)/N</span><br><span class="line">  larger = <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&gt;average, scores)))</span><br><span class="line">  number = <span class="built_in">round</span>(larger/N*<span class="number">100</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;&#123;:.3f&#125;%&quot;</span>.<span class="built_in">format</span>(number))</span><br></pre></td></tr></table></figure><p>list 안의 값들 중 평균값보다 큰 값들만 구하기 위해서는 filter를 사용하면 되고 소숫점 셋째자리까지 나타내었을때 0을 추가로 넣고 싶다면 {:.3f}로 표기하면 되는데 소숫점 뒤에 3자리까지 0으로 채운다는 의미이다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/book/">book</category>
      
      <category domain="https://rimiiii.github.io/tags/review/">review</category>
      
      
      <comments>https://rimiiii.github.io/2021/05/06/baekjoon4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>참고할만한 노션 템플릿 모음</title>
      <link>https://rimiiii.github.io/2021/04/30/notion-template/</link>
      <guid>https://rimiiii.github.io/2021/04/30/notion-template/</guid>
      <pubDate>Fri, 30 Apr 2021 03:39:29 GMT</pubDate>
      
      <description>&lt;p&gt;참고하기 좋은 노션 템플릿 모아두기&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>참고하기 좋은 노션 템플릿 모아두기</p><span id="more"></span><h2 id="템플릿"><a href="#템플릿" class="headerlink" title="템플릿"></a>템플릿</h2><p><a href="https://blog.naver.com/shryu1221"><code>맘퍼스트</code></a><br><a href="https://s20202.tistory.com/category/%EC%83%9D%EC%82%B0%EC%84%B1%20%ED%88%B4/%EB%85%B8%EC%85%98%20notion"><code>패드쓰는 단호박</code></a></p><h2 id="꾸미기용-사이트"><a href="#꾸미기용-사이트" class="headerlink" title="꾸미기용 사이트"></a>꾸미기용 사이트</h2><p><a href="https://giphy.com/"><code>giphy</code></a></p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/REFERENCE/">REFERENCE</category>
      
      
      <category domain="https://rimiiii.github.io/tags/notion/">notion</category>
      
      
      <comments>https://rimiiii.github.io/2021/04/30/notion-template/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>참고할만한 기술 블로그 모음</title>
      <link>https://rimiiii.github.io/2021/04/29/tech-blog/</link>
      <guid>https://rimiiii.github.io/2021/04/29/tech-blog/</guid>
      <pubDate>Thu, 29 Apr 2021 03:49:29 GMT</pubDate>
      
      <description>&lt;p&gt;참고하기 좋은 기술 블로그 모아두기&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>참고하기 좋은 기술 블로그 모아두기</p><span id="more"></span><h2 id="기업-블로그"><a href="#기업-블로그" class="headerlink" title="기업 블로그"></a>기업 블로그</h2><p><a href="https://blog.banksalad.com/tech/"><code>뱅크샐러드</code></a><br><a href="https://medium.com/daangn"><code>당근마켓</code></a><br><a href="https://woowabros.github.io/"><code>우아한형제들</code></a><br><a href="https://blog.lunit.io/"><code>루닛</code></a><br><a href="https://blog.linewalks.com/"><code>라인웍스</code></a><br><a href="https://kakaoenterprise.github.io/papers/"><code>카카오 엔터프라이즈</code></a></p><h2 id="개인-블로그"><a href="#개인-블로그" class="headerlink" title="개인 블로그"></a>개인 블로그</h2><p><a href="https://blossominkyung.com/"><code>blossominkyung</code></a><br><a href="https://tech.oliveyoung.co.kr/"><code>올리브영</code></a><br><a href="https://baeseongsu.github.io/"><code>Seongsu</code></a><br><a href="https://harrydrippin.github.io/"><code>Seunghwan Hong</code></a><br><a href="https://wansook0316.github.io/"><code>에그머니</code></a><br><a href="https://mishka.kr/"><code>Mishka&#39;s Blog</code></a><br><a href="https://sgc109.github.io/"><code>Sungho&#39;s Blog</code></a></p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/REFERENCE/">REFERENCE</category>
      
      
      <category domain="https://rimiiii.github.io/tags/blog/">blog</category>
      
      
      <comments>https://rimiiii.github.io/2021/04/29/tech-blog/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 8958번 OX퀴즈</title>
      <link>https://rimiiii.github.io/2021/04/19/baekjoon3/</link>
      <guid>https://rimiiii.github.io/2021/04/19/baekjoon3/</guid>
      <pubDate>Mon, 19 Apr 2021 13:21:29 GMT</pubDate>
      
      <description>&lt;p&gt;다음과 같은 OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>다음과 같은 OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.</p><span id="more"></span><p>“OOXXOXXOOO”와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다. “OOXXOXXOOO”의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.</p><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>각 테스트 케이스마다 점수를 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case_num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(case_num):</span><br><span class="line">  test_case = <span class="built_in">input</span>()</span><br><span class="line">  score = <span class="number">0</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> test_case:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="string">&quot;X&quot;</span>:</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">    score += count  </span><br><span class="line">  <span class="built_in">print</span>(score)</span><br></pre></td></tr></table></figure><p>O가 연속으로 나올때마다 점수가 올라가야되므로 for문을 이용해서 count를 세는 법을 택했다. 그러다가 X가 나오면 다시 count를 리셋하기 위해서 0으로 돌려준다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://rimiiii.github.io/tags/python/">python</category>
      
      
      <comments>https://rimiiii.github.io/2021/04/19/baekjoon3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 1110번 더하기 사이클</title>
      <link>https://rimiiii.github.io/2021/04/15/baekjoon2/</link>
      <guid>https://rimiiii.github.io/2021/04/15/baekjoon2/</guid>
      <pubDate>Thu, 15 Apr 2021 13:32:29 GMT</pubDate>
      
      <description>&lt;p&gt;아래와 같은 N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>아래와 같은 N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.</p><span id="more"></span><p>0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자. 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. </p><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>첫째 줄에 N의 사이클 길이를 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">number = original = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    number = (number%<span class="number">10</span>)*<span class="number">10</span> + ((number//<span class="number">10</span> + number%<span class="number">10</span>) % <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> number == original:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>초반엔 헤맸는데 십의 자리 숫자와 일의 자리 숫자를 구하는 법이 생각이 나지 않았다. //를 이용해서 십의 자리 숫자를 구하고 %를 이용해서 일의 자리 숫자를 구하여 새로운 숫자를 기존의 number에 넣고 제일 처음으로 받은 숫자를 number에 할당하는 동시에 original에도 함께 할당하면 쉽게 문제가 풀린다. </p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://rimiiii.github.io/tags/python/">python</category>
      
      
      <comments>https://rimiiii.github.io/2021/04/15/baekjoon2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Python/백준] 10871번 X보다 작은 수</title>
      <link>https://rimiiii.github.io/2021/03/29/baekjoon1/</link>
      <guid>https://rimiiii.github.io/2021/03/29/baekjoon1/</guid>
      <pubDate>Mon, 29 Mar 2021 03:27:29 GMT</pubDate>
      
      <description>&lt;p&gt;정수 N개로 이루어진 수열 A와 정수 X가 주어진다. 이때, A에서 X보다 작은 수를 모두 출력하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>정수 N개로 이루어진 수열 A와 정수 X가 주어진다. 이때, A에서 X보다 작은 수를 모두 출력하는 프로그램을 작성하시오.</p><span id="more"></span><h1 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h1><p>첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000)<br>둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다.</p><h1 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h1><p>X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다.</p><h1 id="첫-풀이"><a href="#첫-풀이" class="headerlink" title="첫 풀이"></a>첫 풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N, X = sys.stdin.readline().split()</span><br><span class="line">n = sys.stdin.readline().split()</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">int</span>(i) &lt; <span class="built_in">int</span>(X):</span><br><span class="line">    result.append(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(result))</span><br></pre></td></tr></table></figure><h1 id="개선된-풀이"><a href="#개선된-풀이" class="headerlink" title="개선된 풀이"></a>개선된 풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">N, X = <span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())</span><br><span class="line">n = sys.stdin.readline().split()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">int</span>(i) &lt; <span class="built_in">int</span>(X):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(i), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>N과 X를 int로 변환해야되는데 2개의 변수를 받기 때문에 뒷부분에서 필요할 때 int로 계속 감싸줬다. 그 부분을 찾아보니까 map을 사용해서 int로 각각 변환할 수 있다. 그리고 출력할때 print로 일렬로 세워야해서 result라는 빈 list로 만들어 append로 붙인 다음 join하였는데 print 안의 end를 사용하면 간단하게 된다.</p>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/">ALGORITHM</category>
      
      <category domain="https://rimiiii.github.io/categories/ALGORITHM/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://rimiiii.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://rimiiii.github.io/tags/python/">python</category>
      
      
      <comments>https://rimiiii.github.io/2021/03/29/baekjoon1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Linux] tmux 사용법</title>
      <link>https://rimiiii.github.io/2020/07/03/linux1/</link>
      <guid>https://rimiiii.github.io/2020/07/03/linux1/</guid>
      <pubDate>Fri, 03 Jul 2020 05:16:32 GMT</pubDate>
      
      <description>&lt;p&gt;리눅스에서 하나의 창이 아닌 여러 창을 함께 사용할 때 유용한 &lt;code&gt;tmux 사용법&lt;/code&gt;이다. 리눅스 원격 연결이 꺼져도 서버가 꺼지지 않는 이상 tmux로 돌려놓은 코드는 다운되지 않는다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>리눅스에서 하나의 창이 아닌 여러 창을 함께 사용할 때 유용한 <code>tmux 사용법</code>이다. 리눅스 원격 연결이 꺼져도 서버가 꺼지지 않는 이상 tmux로 돌려놓은 코드는 다운되지 않는다.</p><span id="more"></span><h1 id="tmux-구성-요소"><a href="#tmux-구성-요소" class="headerlink" title="tmux 구성 요소"></a>tmux 구성 요소</h1><ul><li>session: 여러 윈도우로 구성</li><li>window: 터미널 화면, 세션 내에서 탭처럼 사용 가능</li><li>pane: 하나의 윈도우 내에서의 화면 분할</li></ul><h1 id="session-관련-명령어"><a href="#session-관련-명령어" class="headerlink" title="session 관련 명령어"></a>session 관련 명령어</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 새로운 세션 생성</span><br><span class="line">tmux new -s (session_name)</span><br><span class="line"></span><br><span class="line"># 세션 만들면서 윈도우랑 같이 생성</span><br><span class="line">tmux new -s (session_name) -n (window_name)</span><br><span class="line"></span><br><span class="line"># 세션 종료</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 세션 목록</span><br><span class="line">tmux ls</span><br><span class="line"></span><br><span class="line"># 세션 다시 시작하기(다시 불러오기)</span><br><span class="line">tmux attach -t session_number</span><br><span class="line"></span><br><span class="line"># 세션 중단하기</span><br><span class="line">(ctrl + b) d</span><br><span class="line"></span><br><span class="line"># 스크롤하기</span><br><span class="line">ctrl + b + [</span><br><span class="line"></span><br><span class="line"># 특정 세션 강제 종료</span><br><span class="line">tmux kill-session -t session_number</span><br></pre></td></tr></table></figure><h1 id="윈도우-관련-명령어"><a href="#윈도우-관련-명령어" class="headerlink" title="윈도우 관련 명령어"></a>윈도우 관련 명령어</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 새 윈도우 생성</span><br><span class="line">(ctrl + b) c</span><br><span class="line"></span><br><span class="line"># 새 윈도우 이동</span><br><span class="line">(ctrl + b) b (숫자)</span><br></pre></td></tr></table></figure><h1 id="틀-관련-명령어"><a href="#틀-관련-명령어" class="headerlink" title="틀 관련 명령어"></a>틀 관련 명령어</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 틀 나누기</span><br><span class="line">(ctrl + b) % #좌우로 나누기</span><br><span class="line">(ctrl + b) &quot; #위아래로 나누기</span><br><span class="line"></span><br><span class="line"># 틀끼리 이동하기</span><br><span class="line">(ctrl + b) 방향키</span><br><span class="line">(ctrl + b) q</span><br><span class="line">(ctrl + b) o #순서대로 이동</span><br><span class="line"></span><br><span class="line"># 틀 삭제</span><br><span class="line">(ctrl + d)</span><br><span class="line"></span><br><span class="line"># 틀 사이즈 조정</span><br><span class="line">(ctrl + b) : resize_pane -L 10 #L,R,U,D 입력하면 상하좌우로 조절됨</span><br><span class="line">(ctrl + b) (alt) 방향키</span><br><span class="line"></span><br><span class="line"># 단축키 목록</span><br><span class="line">(ctrl + b) ?</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://rimiiii.github.io/categories/LINUX/">LINUX</category>
      
      
      <category domain="https://rimiiii.github.io/tags/tmux/">tmux</category>
      
      
      <comments>https://rimiiii.github.io/2020/07/03/linux1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
